#ifndef DATAFUN_CPP
#define DATAFUN_CPP DATAFUN_CPP

#include <iostream>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>

#include "tiffio.h"
#include "datafun.h"



//importsemtif takes the string of a path to the image that should be imported, and pointers to the image matrix, with and higth variables of the image.
//importsemtif will automatically allocate memory for the double array that is the image matrix, but the pointers to with and hight have to be already allocated.
//this function is fine tuned to import tif images generated by the SEM software in the cellar of the INM, it might not work for any other images.
//the arguments  are :"/path/to/image.tif" ; double uint8 pointer in which the image will be written, pointer in which the with of the image will be written ; pointer in wich the hight of the image will be written.
//returns 0 if sucsessful, 1 if not.
bool importsemtif(const char* path,uint8** &img,uint32* with, uint32* height, float* xres, float* yres){
	TIFF* tif = TIFFOpen(path, "r"); //opens the image file
	
	if (tif) {
		uint32* raster;
		
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, with); //find the with and hight of the image
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, height);
		TIFFGetField(tif, TIFFTAG_XRESOLUTION, xres);
		TIFFGetField(tif, TIFFTAG_YRESOLUTION, yres);
		
		size_t npixels = (*with) * (*height); //calculate the total number of pixels
		img = new uint8*[(*with)]; //allocate the first dimension of the image matrix. this has to be done by the function itsself, because before opening the image the dimensions of the image might not be known.
		
		raster = (uint32*) _TIFFmalloc(npixels * sizeof(uint32)); //allocate a buffer in which the image information will be temporarily written
		if (raster != NULL) { //check if raster was sucsessfully allocated
			if (TIFFReadRGBAImageOriented(tif,*with,*height,raster,ORIENTATION_TOPLEFT,0)){ // write image information in the raster buffer and check weather this was sucsessful
				for (uint32 x = 0; x < (*with); ++x){  
				img[x] = new uint8[*height]; //allocate the second dimension of the image matrix
					for(uint32 y = 0; y < *height; ++y){ 
						img[x][y] = ((raster[y * *with + x]) & 0x000000ff); //"raster" entrys are 32 bit or 4 byte long. the first byte is the alpha and constantly 255. the second, third and forth byte are encoding read green and blue, but since this is a black and white image, they are the same. therefore it is suficcient to take the data from the last byte.
					}
				}
			}else{
				return 1; //if something went wrong the function will return 1
			}
		}else {
			return 1;
		}
		
		_TIFFfree(raster); //free up buffer
	}else {
		return 1;
	}
	TIFFClose(tif);	//close the image file again
	return 0;
}

#endif
