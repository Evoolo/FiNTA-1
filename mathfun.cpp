#ifndef MATHFUN_CPP
#define MATHFUN_CPP MATHFUN_CPP

#include <iostream>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <string.h>



#include <opencv2/opencv.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>

// takes a 2 dimensional array of uint8 representing a image(as generated by importsemtif), the with and hight of the image and fouriertransforms it. the output has to be dereferenced in the form [(x*hight) + y] since it is a single dimensional array.
fftw_complex* fft_2d(uint8** img,unsigned long long w, unsigned long long h){
	
	fftw_complex *in, *out;
	fftw_plan p;
	
	in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * w * h);
	out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * w * h);
	
	p = fftw_plan_dft_2d(w,h,in,out,FFTW_FORWARD, FFTW_ESTIMATE);
	
	for(unsigned long long i = 0; i < w; ++i){
		for (unsigned long long j = 0; j < h; ++j){
			in[(i * h) + j][0] =  (double)img[i][j]; // the in[(i * h) + j][0] referes to the real part of the fftw_complex data type
		}
	}
	
	fftw_execute(p);
	
	fftw_destroy_plan(p);
	fftw_free(in);
	return out;
}



fftw_complex* fft_2d(const cv::Mat &img){
	
	fftw_complex *in, *out;
	fftw_plan p;
	
	cv::Size s = img.size();
	
	in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * s.width * s.height);
	out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * s.width * s.height);
	
	p = fftw_plan_dft_2d(s.width,s.height,in,out,FFTW_FORWARD, FFTW_ESTIMATE);
	
	
	for(unsigned long long i = 0; i < s.height; ++i){
		for (unsigned long long j = 0; j < s.width; ++j){
			in[(j * s.height) + i][0] = img.at<uchar>(i,j); // the in[(i * h) + j][0] referes to the real part of the fftw_complex data type
		}
	}
	
	fftw_execute(p);
	
	fftw_destroy_plan(p);
	fftw_free(in);
	return out;
}




// takes a array of fftw_complex to be dereferenced by[(x*hight) + y] (as generated by fft_2d) with hight h and with w and inverse fourier transforms it. it also frees the memory of the input array when free == 1.
fftw_complex* ifft_2d(fftw_complex* in, unsigned long long w, unsigned long long h, bool free = 1){
	fftw_complex *out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * w * h);
	fftw_complex *buffer = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * w * h); // zhis haz to be done!!! because creating ze plan can overwrite both arrays, which would be horrible if the actual input data was used here and overwritten. if the output is overwirtten i dont care because it will be overwitten again with the correct output anyway
	fftw_plan p = fftw_plan_dft_2d(w,h,buffer,out,FFTW_BACKWARD,FFTW_ESTIMATE);
	fftw_free(buffer);
	
	fftw_execute_dft(p,in,out); //execute the plan but on the actual input data not the array used to create it.
	
	
	
	fftw_destroy_plan(p);
	if(free) {
		fftw_free(in);
	}
	return out;
	
}




// like ifft_2d but it outputs the data in a nice 2D array od real values.
double** ifft_2d_real(fftw_complex* in, unsigned long long w, unsigned long long h, bool free = 1){
	fftw_complex* comp = ifft_2d(in,w,h);
	
	double** img = new double*[w];
	
	for(unsigned long long x = 0; x < w; ++x){
		img[x] = new double[h];
		for(unsigned long long y = 0; y < h; ++y){
			img[x][y] = comp[(x * h) + y][0] /(w * h); // the ffwt library does not normalize the data so the data has to be devided by w*h
		}
	}
	
	if (free){
		fftw_free(comp);
	}
	return img;
}

cv::Mat cv_ifft_2d_real(fftw_complex* in, unsigned long long w, unsigned long long h, bool free = 1){
	fftw_complex* comp = ifft_2d(in,w,h);
	
	cv::Mat img(h,w,CV_64F,cv::Scalar::all(0));
	
	for(unsigned long long x = 0; x < w; ++x){
		for(unsigned long long y = 0; y < h; ++y){
//			img.data[(y * w) + x] = comp[(x * h) + y][0] /((double)w * (double)h); // the ffwt library does not normalize the data so the data has to be devided by w*h
			img.at<double>(y,x) = comp[(x * h) + y][0] /((double)w * (double)h);
		}
	}
	
	if (free){
		fftw_free(comp);
	}
	return img;
}



void cutinneroval_ft(fftw_complex* img,double rad,unsigned long w, unsigned long h){
	rad = (pow(w,2) + pow(h,2)) * rad/4.0;
	double rel = sqrt(w/h);
	double xcent = w/2.0;
	double ycent = h/2.0;
	for(unsigned long x = 0; x < w; ++x){
		for(unsigned long y = 0; y < h; ++y){
			if ((x <= xcent && y <= ycent && (pow((x/rel),2) + pow((y*rel),2) < rad)) || (x >= xcent && y <= ycent && pow(((w - x)/rel),2) + pow((y*rel),2) < rad) || (x <= xcent && y >= ycent && pow((x/rel),2) + pow(((h - y)*rel),2) < rad) || (x >= xcent && y >= ycent && pow(((w - x)/rel),2) + pow(((h - y)*rel),2) < rad)){
				img[(x * h) + y][0] = 0;
				img[(x * h) + y][1] = 0;
			}
		}
	}
}

void cutouteroval_ft(fftw_complex* img,double rad,unsigned long w, unsigned long h){
	rad = (pow(w,2) + pow(h,2)) * rad/4.0;
	double rel = sqrt(w/h);
	double xcent = w/2.0;
	double ycent = h/2.0;
	for(unsigned long x = 0; x < w; ++x){
		for(unsigned long y = 0; y < h; ++y){
			if ((x <= xcent && y <= ycent && (pow((x/rel),2) + pow((y*rel),2) > rad)) || (x >= xcent && y <= ycent && pow(((w - x)/rel),2) + pow((y*rel),2) > rad) || (x <= xcent && y >= ycent && pow((x/rel),2) + pow(((h - y)*rel),2) > rad) || (x >= xcent && y >= ycent && pow(((w - x)/rel),2) + pow(((h - y)*rel),2) > rad)){
				img[(x * h) + y][0] = 0;
				img[(x * h) + y][1] = 0;
			}
		}
	}
}


#endif